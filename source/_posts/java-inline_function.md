---
title:  浅谈 Inline(内联)函数
---

#### 为什么会出现内联函数？

要回答这个问题，首先说说方法的调用过程：

调用某个函数实际上将程序执行顺序转移到该方法所存放在内存中的某个地址，再返回到转去执行该函数前的地方。
这种转移操作要求在转去前要保护现场并记忆执行的地址，转回后先要恢复现场，并按原来保存地址继续执行。
也就是通常说的压栈和出栈。因此，函数调用要有一定的时间和空间方面的开销。那么对于那些函数体代码不是很大，
又频繁调用的函数来说，这个时间和空间的消耗会很大。

那么怎么解决性能消耗的问题呢？

这个时候需要引入内联函数了。内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换。
显然，这样就不会产生转去转回的问题，但是由于在编译时将函数体中的代码被替代到程序中，因此会增加目标程序代码量，进而增加空间开销，
而在时间代销上不象函数调用时那么大，可见它是以目标代码的增加为代价来换取时间的节省。

写过C++代码的应该都知道，在C++里有个内联函数，使用inline关键字修饰。另外，写在Class定义内的函数也会被编译器视为内联函数。

那么，在Java中的内联函数长什么模样呢？在java中使用final关键字来指示一个函数为内联函数，例如：
```
public final void method1() {
   //TODO something
}
```

这个指示并不是必需的。final关键字只是告诉编译器，在编译的时候考虑性能的提升，可以将final函数视为内联函数。但最后编译器会怎么处理，编译器会分析将final函数处理为内联和不处理为内联的性能比较了。

该方法在被调用时，会在调用处直接展开使用，从而提高程序执行速度。此外final关键字还有一个作用，防止doSomething方法在子类中被覆盖，如果你希望doSomething是一个最终行为的话，那它应该被设计成final。

内联不一定好，当被指定为内联的方法体很大时，展开的开销可能就已经超过了普通函数调用调用的时间，引入了内联反而降低了性能，因为在选择这个关键字应该慎重些，不过，在以后高版本的JVM中，在处理内联时做出了优化，它会根据方法的规模来确定是否展开调用。